- 객체.setter
	- **단순한 상태 변경**이 필요한 경우:
- 객체 = new 객체
	- **객체의 불변성**이 중요한 경우

|방법|장점|단점|사용 사례|
|---|---|---|---|
|**Setter 사용**|단순하고 직관적이며 구현이 쉽다|캡슐화 약화, 상태 추적이 어려울 수 있음|일반적인 객체 설계|
|**새 객체 반환**|불변성 보장, 스레드 안전|객체 생성 비용 증가, 코드 복잡성 증가|불변 객체(예: `String`, `BigDecimal`) 설계|

---
#### 객체를 메서드의 인수로 전달한 경우
- **setter를 사용하여 속성을 변경하면 원본 객체도 변경되지만**, 
- 새 객체를 선언하면 원본 객체는 변경되지 않습니다.

⁇ 참조란
- 객체가 위치한 메모리 주소
- 객체의 속성에 접근하거나 변경할 때 사용

##### setter
	- 주입한 객체의 상태가 변경됨
```java
public void matching(PairResult pairResult){  
    pairResult.set(findSamePairResult(pairResult,isAgain));  
}
```

##### 새로운 객체 생성
	- 주입한 객체의 상태가 변경되지 않음
```java
//외부
matching(pairResult-1); 

public void matching(PairResult pairResult-2){
    pairResult-3 = findSamePairResult(pairResult,isAgain);  
}
```
- pairResult-1 : 외부에서 주입한 원본 객체 
- pairResult-2 : 매개변수로 원본 객체의 참조값을 복사, 즉 동일한 객체를 가르키는 참조
- pairResult-3 : findSamePairResult(()가 실행되기전까지는 원본 객체를 참조하지만, 새로운 객체를 선언하면서 아예 새로운 객체가 되어버림
	- `pairResult = new PairResult();`는 힙 메모리에 새로운 객체를 생성하고, 새로운 메모리 주소(예: `0x5678`)를 `pairResult`에 저장
	- 즉, 원본과 메모리 주소가 바뀜

|**상황**|**원본 객체 변경 여부**|**설명**|
|---|---|---|
|**참조를 사용하여 속성 변경**|변경됨|전달된 참조를 통해 원본 객체의 속성을 직접 수정.|
|**새로운 객체 생성**|변경되지 않음|메서드 내부에서 새로운 객체를 생성해도 원본 참조는 영향받지 않음.|
#### 이유
자바에서 객체를 메서드의 인수로 전달할 때, **참조(reference)가 전달**된다. 이 참조를 사용하여 객체의 속성을 변경하면 원본 객체의 속성도 함께 변경됩니다. 그러나 새로운 객체를 생성하면 원본 객체는 참조가 유지되므로, 영향을 받지 않는다.