
1. **서비스(주요 로직)**, Result(boolean, add)
2. **Result(주요 로직)**, 서비스(지시)
3. **helper(주요 로직)**, Result(helper위임),서비스(지시)
---
#### **서비스에서 주요 로직을 처리하는 경우**

1. **복잡하고 따져야 할 경우의 수가 많을 때**
    - `Result` <mark style="background: #FFF3A3A6;">객체가  많은 상태 반환과 유효성 검사</mark>를 주로 담당할때,
    - ex): `할인 -> 증정품 -> 배지 추가`처럼 **단계적 로직**을 구현해야 할 때, 각각의 처리가 독립적이지 않고 결합도가 높은 경우 서비스가 중심이 된다.
2. **로직에 필요한 객체가 많을 때**
    - 로직이 여러 객체(`Schedule`, `Cart`, `Wallet` 등)와 협력해야 할 경우
    - 서비스는 이 객체들을 조율하는 역할을 담당.
    - ex) `EventPlan` 생성 시 `Schedule`, `Cart`, `Wallet`과의 협력 필요.
3. **행동이 단일 단계로 끝나지 않을 때**
    - 하나의 행동에서 다른 행동으로 이어지는<mark style="background: #FFF3A3A6;"> 단계적 로직이 필요할 경우</mark>, 서비스가 적합합니다.
    - 예: "A를 처리한 뒤 상태를 보고 B를 추가"하는 방식.
4. **헬퍼(helper)를 사용해야 하며, 자신(`this`)을 주입해야 할 경우**
    - this를 넘긴다는 것은 객체가 상태,유효처리가 복잡하다는 것이므로 서비스에서 한다.

#### **Result 객체 안에서 주요 로직을 처리하는 경우**
1. **Result가 가진 데이터끼리 생성해야 하는 경우**
    - <mark style="background: #FFF3A3A6;">내부 데이터와 연관된 로직</mark>이라면 `Result`가 이를 처리하는 것이 적합.
    - ex) `Result`의 필드끼리 조합하여 새로운 상태를 계산하거나 생성.
2. **데이터 캡슐화가 필요한 경우**
    - 내부 데이터를 <mark style="background: #FFF3A3A6;">캡슐화</mark> 하고 행동을 수행해야 할 때, `Result`가 로직을 스스로 처리합니다.
    - 단,너무 복잡한 경우, 헬퍼 객체에 위임.

#### **헬퍼(helper)를 활용한 설계**
- **Result 객체 내부에서 헬퍼를 사용하는 경우** - <mark style="background: #FFF3A3A6;">캡슐화</mark>
    - 로직이 복잡하지만, 데이터 캡슐화를 유지해야 할 때 헬퍼를 활용합니다.
    - 헬퍼는 외부 객체가 아닌 `Result` 내부에서만 접근 가능하며, 헬퍼와 `Result`는 강하게 결합됩니다.
    - 헬퍼에게 전해지는 인수는 테스트가 쉬운 가장 기초 자료형이 된다.
- **서비스에서 헬퍼를 사용하는 경우**
	- 캡슐화가 필요 없을 때
    - 헬퍼를 통해 복잡한 로직을 서비스에서 실행하고, `Result`에 결과를 전달하는 방식입니다.
    - **이 경우에는 상태 검증 로직이 주로 헬퍼로 위임**됩니다.