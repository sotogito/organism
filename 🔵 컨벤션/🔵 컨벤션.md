- 테스트 코드를 먼저 확인하라
- <mark style="background: #FFF3A3A6;">만약 구현 방법 자세히 제시되었다면, 구현 방법 대로 구현하라.</mark>
- ~한 형태로 준비하라면 그대로 준비하라 ex) List<String,>
- finder 같은 기능을 통해 객체의 종류를 아예 변경하고 싶다면 return을 사용하라
- 기존 제공하는 데이터는 static{} 에서 추가하라.
- 문자, 숫자등을 parser할때는 trim()을 사용하라
- 기능을 각주로 설명하지 말고 메서드로 설명하라
- 가장 기본적으로 처리해야될 로직부터 작성하라 ex) ""입력되면 0을 출력
- input에서 `return Console.readLine();` try-catch 로 감싸서 넘겨라
	내부적으로 Scanner.nextLine 를 사용하고 있기 때문에, 빈 문자열을 입력 받을 경우, `NoSuchElementException` 예외가 발생할 수 있다.
- 출력물이 객체로 생성하기 적절한지 고려하라
	예를들어 2주차 과제 자동차 경주에서 , 출력물은
	1. 자동차 이름
	2. 거리 + repeat(-)
	였다. 이 출력 데이터는 history 데이터가 될 수 있다.
	객체로 생성해도 충분하다.
	즉, 아래와 같은 객체가 있으면 좋다.
	- 시도 횟수 몇번째인지
	- car
	- 출력에 필요한 상수
- 출력은 하나씩 하지 말고 한번에 하라
- 서비스에서 직접 출력을 할 수 없지만, 출력에 필요한 데이터는 반환할 수 있다.
	자동차 경주에서 중간 결과를 출력할 수는 없지만 중간 결과를 출력형태로 계속 저장한 데이터를 반환할 수는 있다.
- 최종 출력 결과 데이터도 객체가 될 수 있다.
- 주요 로직에 필요한 객체가 2개 이상이면 서비스 생성을 고려해봐라
- 다시 사용해야할 데이터의 경우 객체의 필드로 저장하라
- 사용자의 입력에 따라 바뀌는 데이터는 객체로 컨트롤러에서 생성 후 서비스 인수로 전달하라
- 서비스 생성자에는 고정적인 의존성(calculator)만 주입하라.
- 객체는 한가지의 역할을 수행하되, 필요한 상태와 행동은 여러개여도 괜찮다. - 단일 책임의 원칙
- 2가지 객체가 필요한 경우는 서비스에서 처리하는게 더 나을지도 모른다.
- 출력에 필요한, 다른 클래에서 필요한 데이터는 컨트롤러에서 객체를 만들어 의존성을 주입하라
- Enum데이터 리스트는 Enum이 생성해서 반환하도록 하라
- Randoms의 어떤 기능을 사용하라고 명시되어있는지 확인하고 구현하라
- 일단 final로 선언한 추후 업데이트해야하면 리스트 자체를 인수로 넘겨라
- 특정 리스트를 반환할때는 그 데이터를 가지고 있는 클래스에서 반환하도록하라
- Y,N같은 특정 입력값 처리는 String이 아닌 Enum 상수로 넘겨라
- 테스트를 위해 메서드의 인수는 객체가 아닌 데이터로 넘겨라
	```java
	public List<OneBlock> getNowBridge(int order) {  
    List<OneBlock> result = new ArrayList<>();  
    for (int i = 0; i < order; i++) {  
        result.add(bridge.get(i));  
    }  
    return result;  
	}
	```
- **중첩된 while문**에서 바깥쪽 while문을 완전히 종료하려면, 내부의 while문을 먼저 빠져나와야 한다.
- 반복,종료 조건이 복잡하다면 While(true)를 사용하고 중첩되지 않는 if문을 사용하라
	- - 가장 큰 종료 조건(아예 게임 종료)일수록 가장 상위에 둬라
		- 아래로 갈수록 완전 종료에 영향을 적게 
- 리스트를 for문 돌리면서 해당 요소를 삭제하지 마라
	- `for-each`문을 사용하면서 리스트의 요소를 직접 삭제하는 경우 동시성 문제가 생겨 예외가 발생된다.
		- `ConcurrentModificationException`
	- removeIf를 사용하여 안전하게 삭제하라
- 바로 결과를 반환하는게 아니면 if문으로 반환하라
	- public boolean hasSamePairCrewSingly(PairCrew newPairCrew) {  
    for (PairCrew pairCrew : pairCrews) {  
        if (pairCrew.haveSamePairCrewSingly(newPairCrew)) {  
            return true;  
        }  
    }  
    return false;  
	}
	
		위의 코드는 만약 같다면 true를 넘기고 아니라면 for문을 다시 돈다.
		즉, 모든 for문을 해당하는 조건이 나올때까지 순환한다.
	
	public boolean hasSamePairCrewSingly(PairCrew newPairCrew) {  
    for (PairCrew pairCrew : pairCrews) {  
        return pairCrew.haveSamePairCrewSingly(newPairCrew))
    }  
    return false;  
    }
	    비슷해보이지만 위의 코드는 바로 결과를 반환한다.
- 복잡하지만 서로 묶여 많이 사용되는 데이터라면 DTO를 생성하라 
	- public record MissionTypeDto(Course course, Level level, Mission mission) {
- 단순히 묶기 위해서는 record를 생성하라
	- 만약 객체로 생성할 경우 묶은 클래스에 중복된 메서드가 위임되어 생겨나게된다.
	- 기초적인 객체(Wallet,Amount)만 생성하고 record로 묶어라
- 추후 하나씩 추가해야할 데이터가 아니면 생성자를 통해 생성하라
- 한번에 유효검사를 해야할때는 생성자를 통해 생성하라
- 빈 값을 split하여 List<String,>을 만들면 사이즈가 1이다
	- 빈 값 그대로 처리하고 싶으면 split 전에 처리한다.
- 객체는 인수로 넣어준다면 새로 참조하지 않는 이상 밖의 객체와 동기화되지만, int,boolean같은 자료형은 안된다.
- 객체를 equal로 정의했으면 반드시 비교할때 .equal를 사용하라, ==를 사용하지 말하라.
- map은 key로 조회하기는 쉽지만, value로 조회와, 인덱스로 특정 값을 가져올 수 없다는 단점이 있다.
- Map을 인덱스로 순회하고 싶다면 `List<Map.Entry>`를 만들어라