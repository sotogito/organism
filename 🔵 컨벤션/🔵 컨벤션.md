- 테스트 코드를 먼저 확인하라
- <mark style="background: #FFF3A3A6;">만약 구현 방법 자세히 제시되었다면, 구현 방법 대로 구현하라.</mark>
- ~한 형태로 준비하라면 그대로 준비하라 ex) List<String,>
- finder 같은 기능을 통해 객체의 종류를 아예 변경하고 싶다면 return을 사용하라
- 기존 제공하는 데이터는 static{} 에서 추가하라.
- 문자, 숫자등을 parser할때는 trim()을 사용하라
- 기능을 각주로 설명하지 말고 메서드로 설명하라
- 가장 기본적으로 처리해야될 로직부터 작성하라 ex) ""입력되면 0을 출력
- input에서 `return Console.readLine();` try-catch 로 감싸서 넘겨라
	내부적으로 Scanner.nextLine 를 사용하고 있기 때문에, 빈 문자열을 입력 받을 경우, `NoSuchElementException` 예외가 발생할 수 있다.
- 출력물이 객체로 생성하기 적절한지 고려하라
	예를들어 2주차 과제 자동차 경주에서 , 출력물은
	1. 자동차 이름
	2. 거리 + repeat(-)
	였다. 이 출력 데이터는 history 데이터가 될 수 있다.
	객체로 생성해도 충분하다.
	즉, 아래와 같은 객체가 있으면 좋다.
	- 시도 횟수 몇번째인지
	- car
	- 출력에 필요한 상수
- 출력은 하나씩 하지 말고 한번에 하라
- 서비스에서 직접 출력을 할 수 없지만, 출력에 필요한 데이터는 반환할 수 있다.
	자동차 경주에서 중간 결과를 출력할 수는 없지만 중간 결과를 출력형태로 계속 저장한 데이터를 반환할 수는 있다.
- 최종 출력 결과 데이터도 객체가 될 수 있다.
- 주요 로직에 필요한 객체가 2개 이상이면 서비스 생성을 고려해봐라
- 다시 사용해야할 데이터의 경우 객체의 필드로 저장하라
- 사용자의 입력에 따라 바뀌는 데이터는 객체로 컨트롤러에서 생성 후 서비스 인수로 전달하라
- 서비스 생성자에는 고정적인 의존성(calculator)만 주입하라.
- 객체는 한가지의 역할을 수행하되, 필요한 상태와 행동은 여러개여도 괜찮다. - 단일 책임의 원칙
- 절대적인 짝이 되는 데이터는 객체 생성을 고려하라 ex)x,y 좌표
	- Result에 가깝다면 Map의 형태도 괜찮다.
- 하나의 데이터에 동기화된 산태 업데이트가 필요하다면 하나의 객체로 묶어라
- 2가지 객체가 필요한 경우는 서비스에서 처리하는게 더 나을지도 모른다.
- 출력에 필요한, 다른 클래에서 필요한 데이터는 컨트롤러에서 객체를 만들어 의존성을 주입하라
- Enum데이터 리스트는 Enum이 생성해서 반환하도록 하라
- Randoms의 어떤 기능을 사용하라고 명시되어있는지 확인하고 구현하라
- 일단 final로 선언한 추후 업데이트해야하면 리스트 자체를 인수로 넘겨라
- 특정 리스트를 반환할때는 그 데이터를 가지고 있는 클래스에서 반환하도록하라
- Y,N같은 특정 입력값 처리는 String이 아닌 Enum 상수로 넘겨라
- 테스트를 위해 메서드의 인수는 객체가 아닌 데이터로 넘겨라
	```java
	public List<OneBlock> getNowBridge(int order) {  
    List<OneBlock> result = new ArrayList<>();  
    for (int i = 0; i < order; i++) {  
        result.add(bridge.get(i));  
    }  
    return result;  
	}
	```
- **중첩된 while문**에서 바깥쪽 while문을 완전히 종료하려면, 내부의 while문을 먼저 빠져나와야 한다.
- 반복,종료 조건이 복잡하다면 While(true)를 사용하고 중첩되지 않는 if문을 사용하라
	- - 가장 큰 종료 조건(아예 게임 종료)일수록 가장 상위에 둬라
		- 아래로 갈수록 완전 종료에 영향을 적게 
- 리스트를 for문 돌리면서 해당 요소를 삭제하지 마라
	- `for-each`문을 사용하면서 리스트의 요소를 직접 삭제하는 경우 동시성 문제가 생겨 예외가 발생된다.
		- `ConcurrentModificationException`
	- removeIf를 사용하여 안전하게 삭제하라
- 바로 결과를 반환하는게 아니면 if문으로 반환하라
	- public boolean hasSamePairCrewSingly(PairCrew newPairCrew) {  
    for (PairCrew pairCrew : pairCrews) {  
        if (pairCrew.haveSamePairCrewSingly(newPairCrew)) {  
            return true;  
        }  
    }  
    return false;  
	}
	
		위의 코드는 만약 같다면 true를 넘기고 아니라면 for문을 다시 돈다.
		즉, 모든 for문을 해당하는 조건이 나올때까지 순환한다.
	
	public boolean hasSamePairCrewSingly(PairCrew newPairCrew) {  
    for (PairCrew pairCrew : pairCrews) {  
        return pairCrew.haveSamePairCrewSingly(newPairCrew))
    }  
    return false;  
    }
	    비슷해보이지만 위의 코드는 바로 결과를 반환한다.
- 복잡하지만 서로 묶여 많이 사용되는 데이터라면 DTO를 생성하라 
	- public record MissionTypeDto(Course course, Level level, Mission mission) {
- 단순히 묶기 위해서는 record를 생성하라
	- 만약 객체로 생성할 경우 묶은 클래스에 중복된 메서드가 위임되어 생겨나게된다.
	- 기초적인 객체(Wallet,Amount)만 생성하고 record로 묶어라
- 추후 하나씩 추가해야할 데이터가 아니면 생성자를 통해 생성하라
- 한번에 유효검사를 해야할때는 생성자를 통해 생성하라
- 빈 값을 split하여 List<String,>을 만들면 사이즈가 1이다
	- 빈 값 그대로 처리하고 싶으면 split 전에 처리한다.
- 객체는 인수로 넣어준다면 새로 참조하지 않는 이상 밖의 객체와 동기화되지만, int,boolean같은 자료형은 안된다.
- 객체를 equal로 정의했으면 반드시 비교할때 .equal를 사용하라, ==를 사용하지 말하라.
- map은 key로 조회하기는 쉽지만, value로 조회와, 인덱스로 특정 값을 가져올 수 없다는 단점이 있다.
- Map을 인덱스로 순회하고 싶다면 `List<Map.Entry>`를 만들어라
- 객체 생성이 간단하지 않는 한 서비스에서 생성한다.
- Order은[시킨 메뉴-수량]의 상태를 갖는 객체로 생성하며, Cart에서 List<order.> 또는 검색을 생각하여 Map을 고려하라
- 데이터의 존재 확인 후 가져와 로직을 처리하기 위해서는 Option을 사용하라
- <mark style="background: #FF5582A6;">"One-To-Many" 관계보다 "Many-To-One" 관계를 지향하라 - 여러 학생이 하나의 학교를 다닌다.
  단. 코딩테스트에서는 One-To-Many를 먼저 생각하라.</mark>
  ex) 반, 학생들
  ex) 카테고리, 메뉴들
  
	만약 학생student과 반class 가 있다고 가정해보면 반에 학생들을 담지 말고 학생 하나하나에 반을 지정해주라는 얘기이다.
	 - 학교 하나에 여러 학생이 다닌다 ❌
	 - 여러 학생이 하나의 학교에 다닌다 ⭕️
	 class Student { 
		 private String name;
		 private ClassRoom classRoom;

	<mark style="background: #FFF3A3A6;">하지만 이 방법은 구현 방법이 어려울 수도 있다.
	때문에 코딩테스트에서는 One-To-Many를 먼저 생각해본다. 
	만약 One이 상수 즉 Enum으로 작성될 가능성이있으면 더욱더 그렇게 관리한다.
	Map<Calss,List<Student.></mark>

- 2중 Map의 사용도 고려해봐라 - 메뉴추천
	메뉴추천의 경우는 요일별-카테고리별-각직원들의요일별메뉴를 출력해야한다.
	- **요일별 카테고리 매핑**
	    - `Map<Day, Category>`: 각 요일에 어떤 카테고리를 할당할지 저장합니다.
	- **직원별 요일-메뉴 추천 매핑**
	    - `Map<Employee, Map<Day, Menu>>`: 각 직원에게 요일별로 추천된 메뉴를 저장합니다.
- null로 초기화를 하는 것과 new EnumMap<>()으로 초기화 하는 것은 다르다.
- Cart의 자료형을 Map 또는 List<Order.>중에서 고민하라. 만약 공통적으로 갖는 필드가 있다면 Map의 key로 하라
	- 치킨집 포스 - table
- 객체에 추가하는 요소, 삭제하는 요소는 서비스가 아닌 객체 내부에서 판단하도록 하라
	- 예를들어 메뉴추천에서 코치들의 메뉴를 추가할때, 코치들이 음식에 추가하지 못하는 경우는 2가지이다.
	1. 못먹는 메뉴일 때
	2. 이미 들어가있는 메뉴일때
	서비스에서 메뉴를 랜덤 생성하는거까지는 구현하고 이를 추가할때 위의 1,2두가지 경우의 조건문을 가지는 것은 코치 객체 내가 되어야한다. 
	서비스에서는 그냥 add를 해주고<mark style="background: #ABF7F7A6;"> 코치에서 검증+추가 로직</mark>을 갖는 메서드로 add해주면 된다.
	만약 들어가지 않았을 경우 다시 메뉴를 만들어야한다면 boolean으로 확인해주면 된다,
	```java
	public class Coach {
	    private List<String> recommendedMenus;
	    private List<String> notEatableMenus;

		    // 메뉴 추가 + 검증 메서드
	    public boolean addMenu(String menuName) {
	        if (canRecommendMenu(menuName)) {
	            recommendedMenus.add(menuName);
	            return true;
	        }
	        return false;
	    }

	```
	그럼 객체가 좀 더 주체저긍로 행동할 수 잇다.
- Reader에서 파일을 읽어오는 것은 프로그램이 시작할때 미리 생성하지 않고 데이터가 필요할 떄 읽고와도 된다.
- 만약 Key객체를 독립적으로 사용하면서 검색이 가능하다면 Map


Map을 쓸까 List를 쓸까
- 만약 Map의 Key를 독립적으로 사용하는 객ㄱ체이면, Enum이면 Map
예를들어 조회를할때 `EnumMap<Level, List<PairMatching>> pairMatchings;` Level이라는 객체를 따로 관리하면서 ㅈ회한다면 Map 하지만 그게 아니라면 그냥 List를 사용한다.